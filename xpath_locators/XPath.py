import re


class XPath(object):
    """
    A class representing an XPath of WebElement generated by the Robula+ algorithm

    Parameters
    ----------
    object : _type_
        _description_
    """
    
    def __init__(self, value: str):
        self.value = value
        self.length = None
        self.__pieces = None

    def __lt__(self, other):
        return self.value < other.value

    def __gt__(self, other):
        return self.value > other.value

    def __str__(self) -> str:
        return self.value

    def __repr__(self) -> str:
        return self.__str__()

    @property
    def pieces(self):
        if self.__pieces is None:
            self.__pieces = self.value.split('/')
        return self.__pieces

    def startsWith(self, value: str) -> bool:
        return self.value.startswith(value)

    def substring(self, value: int) -> str:
        return self.value[value:]

    def replaceHeadPosition(self, new_pos: int):
        regExp = re.compile('\[\d+\]')
        self.value = re.sub(regExp, f"[{new_pos}]", self.value)

    def headHasAnyPredicates(self) -> bool:
        return '[' in self.pieces[2]

    def headHasPositionPredicate(self) -> bool:
        regExp = re.compile('\[\d+\]')
        return (
            'position()' in self.pieces[2] or 
            'last()' in self.pieces[2] or 
            bool(re.match(regExp, self.pieces[2]))
        )

    def headHasTextPredicate(self) -> bool:
        return 'text()' in self.pieces[2]

    # def splitXPath(self):
    #     if self.__pieces is None:
    #         self.__pieces = self.value.split('/')
    #         i = 0
    #         n = len(self.__pieces) - 1
    #         while i < n:
    #             if self.__pieces[i].find("[") != -1:
    #                 k = i + 1
    #                 while k < len(self.__pieces) and not self.__pieces[i].endswith("]"):
    #                     self.__pieces[i] += self.__pieces[i + 1]
    #                     k += 1
    #                 indices = range(i + 1, k)
    #                 self.__pieces = [p for j, p in enumerate(self.__pieces) if j not in indices]
    #                 n -= k - (i + 1)

    def addPredicateToHead(self, predicate: str):
        self.pieces[2] += predicate
        self.value = '/'.join(self.pieces)

    def getLength(self) -> int:
        if self.length is None:
            length = 0
            for piece in self.pieces:
                if piece:
                    length += 1
            self.length = length
        return self.length
    
    def getHeadTag(self) -> str:
        head = self.pieces[2]
        pred_index = head.find("[")
        if pred_index != -1:
            return head[:pred_index]
        else:
            return head